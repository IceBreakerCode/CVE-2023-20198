#!/usr/bin/env python3

import re
import socket
import ipaddress
import ssl
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
from time import sleep
import argparse

# Configuration
MAX_WORKERS = 15
TIMEOUT = 2
PORT = 443
RETRIES = 3
RATE_LIMIT = 0.5  # in seconds between retries

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)

# Precompiled regex patterns
STATUS_CODE_PATTERN = re.compile(r"HTTP/1.1 (\d+)")
IMPLANT_PATTERN = re.compile(r'^[a-f0-9]{18}\s*$')
HTTP_TEMPLATE = """POST /webui/logoutconfirm.html?logon_hash=1 HTTP/1.1
Host: {host}
User-Agent: Mozilla/5.0 (compatible; SecureCheck/1.0)
Content-Type: application/x-www-form-urlencoded
Content-Length: 0

"""

def create_secure_context():
    """Creates a secure SSL context."""
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    return context

def check_vulnerable(host, success_ips, failed_ips):
    """Check if the given host has a vulnerability."""
    context = create_secure_context()

    retries_left = RETRIES
    while retries_left:
        try:
            with socket.create_connection((host, PORT), TIMEOUT) as s:
                s = context.wrap_socket(s, server_hostname=host)
                s.sendall(HTTP_TEMPLATE.format(host=host).encode())
                data = s.recv(4096).decode(errors='replace')

                status_code = int(STATUS_CODE_PATTERN.search(data).group(1))
                if status_code == 200:
                    body = data.split("\r\n\r\n", 1)[1].strip()
                    if IMPLANT_PATTERN.match(body):
                        logger.info(f"IP: {host} - Found potential implant: {body}")
                        success_ips.append(host)
                        return
                    else:
                        logger.info(f"IP: {host} - Response not matching the expected pattern.")
                        failed_ips.append(host)
                        return
                else:
                    logger.info(f"IP: {host} - Status: {status_code}")
                    failed_ips.append(host)
                    return
        except (socket.timeout, socket.error) as e:
            retries_left -= 1
            logger.warning(f"IP: {host} - Attempt {RETRIES - retries_left + 1} - Error: {e}")
            sleep(RATE_LIMIT)
        except Exception as e:
            logger.error(f"IP: {host} - Exception: {e}")
            failed_ips.append(host)
            return

def scan_subnet(subnet_input):
    """Scan the subnet for vulnerabilities."""
    success_ips = []
    failed_ips = []

    try:
        subnet = ipaddress.IPv4Network(subnet_input, strict=False)
        with ThreadPoolExecutor(MAX_WORKERS) as executor:
            futures = [executor.submit(check_vulnerable, str(ip), success_ips, failed_ips) for ip in subnet.hosts()]
            for future in as_completed(futures):
                future.result()

        logger.info("\nIPs with potential implants:")
        logger.info(', '.join(success_ips))
        logger.info("\nIPs without potential implants:")
        logger.info(', '.join(failed_ips))

        with open('CVE-2023-20198-scan_results.txt', 'w') as f:
            f.write("IPs with potential implants:\n")
            f.write('\n'.join(success_ips))
            f.write("\n\nIPs without potential implants:\n")
            f.write('\n'.join(failed_ips))

    except ValueError:
        logger.error("Please enter a valid subnet in CIDR notation.")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--subnet', required=True, help='The subnet in CIDR notation (e.g. X.X.X.X/24)')
    args = parser.parse_args()
    scan_subnet(args.subnet)

if __name__ == "__main__":
    main()
